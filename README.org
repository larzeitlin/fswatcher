#+TITLE: File System Watcher
* Intro
This File System watcher is an extensible Clojure component for monitoring changes to
file-systems, supporting a range of file-system types (for example: local, s3). It
uses polling and a rules-based engine to trigger actions on changes. It is designed
for extensibility and configurability.

** Scope
This project lays the groundwork but it not complete. It provides a starting point to
allow for further conversation and design, development work on this project.

*** Out of scope
- Comparing across different file-systems.
- All *write* actions on the file-systems.
- Any concept of moving or renaming files. All mutations are expressed as
  creates and deletes.

* Documents

* Overview
** High-level Architecture

#+begin_src ascii
Add a diagram here.
#+end_src


*** The system
The system is a running instance of this component.

In ~fs-watcher.core~ where we have an entry-point with ~run~, which creates a system and
starts polling on a thread by using a ~future~. This keeps the REPL unblocked and also
would allow us to easily support running multiple, concurrent systems if that becomes a
requirement at a later date.

The state of the system is held in the ~system*~ atom.

The system is updated by ~main-loop~ which triggers polls regulated configured interval.

The system is configured to use a ~watcher~ type based on the file-system type.

*** Watchers
A ~FileSystemWatcher~ protocol is defined in ~fs-watcher.watcher~ with methods: ~connect~,
~poll~ and ~disconnect~. The same namespace also provides wrappers for each of these methods
so that implementations of ~FileSystemWatcher~ do not have to re-implement interactions with
the ~system*~ atom. See comments on each wrapper for more details:

[[file:src/fs_watcher/watcher.clj][FileSystemWatcher]]

Watchers are instantiated as records that implement the ~FileSystemWatcher~ protocol.
There is a watcher ~defrecord~ for each type of file-system supported. For example:

[[file:src/fs_watcher/watchers/local_filesystem.clj][LocalFileSystemWatcher]]

We can see that this implements the FileSystemWatcher protocol, using the given wrappers for
each of the methods.

*** Rulesets and Rules
A ruleset is a collection of rules. A rule is a map of ~:condition~ and ~:action~.
both of these are functions that take the previous and new state of the file-system.

Use of, for example, ~clojure.data.diff~ can be useful in conditions and actions.
#+begin_src clojure
{:condition (fn [prev new] ...)
 :action (fn [prev new] ...)}

#+end_src


**** Condition
A predicate that compares the new and previous file-system state. If the condition is met
the action will be triggered. Comparison of the previous and new state of the file-system
gives a broad space of conditions.

**** Action
Simply a function that is triggered when the condition is met. It also takes the previous
and new state of the file-system since this information may be useful. (Note, maybe it should just
have the system* in scope)

**** Rulesets
Rulesets are collection of rules.
Each ruleset has it's own namespace eg: ~fs-watcher.rulesets.ruleset1~.
The ruleset used by a system is set by configuration.

** Running
*** Configuration

* Testing strategy
A layered approach to testing.
So far I have provided some examples of how to test. Full coverage is not completed yet.

The layers of testing are:
- unit
- integration
- end-to-end

** Unit tests
These test individual functions with example data. Here we are using unit tests as much
for documentation as for ensuring correctness.

My personal preference is to avoid heavy, unnecessary unit testing,
which adds a maintenance burden. Unit tests should only be for functions that
have enough complexity to warrant further documentation or checking.

Example of unit testing is the tests for ~fs-watcher/apply-rules~ which can be found here:

[[file:test/fs_watcher/watcher_test.clj][Watcher tests]]

** Integration tests
This slightly higher level test runs over the connection between two subsystems.
Here the main integrations we are interested in are between our component and the target file-systems.
For our local file-system this is rather simple, we can check the watcher methods when pointed at a
local directory.
We also have an example of the more complex case of the S3 watcher integration test. This is more of
a pseudo-integration test since it runs against a ~localstack~ version of S3.

** End-to-end tests
End-to-end tests can be run all-local but more confidence is given by running these sorts of tests
against a deployed system in a test environment.

* Evolution
This is a first pass at a generic file-system watcher component with swappable backends,
interval configuration, rule customization.
Once this is complete, there are several ways enhancement
opportunities:
- Allow for multiple concurrent systems running on the same component, each with it's own ruleset and
  other configurations.
- Remote REPL access, allowing for runtime debugging and runtime edits to configuration.

* Trade-offs and Improvement Opportunities
** Ruleset creation requires code changes
*** Limitation
Currently, rulesets are defined directly in code.
Adding or modifying rules necessitates a code change and redeployment,
which can slow down iteration and limit flexibility for end users.
*** Potential improvement
Develop a domain-specific language or configuration format for defining rules.
This would allow rules to be specified in external files or configuration,
empowering users to create or modify rules without touching code.
**** Trade-off
introducing a DSL could limit the expressiveness of rules or increase system complexity.
The right balance depends on the target audience and use cases

*** Impact
This approach restricts the ability of non-developers or operators to
create or adjust rules on the fly, potentially reducing the system's adaptability.

** Initial file-system representation
*** Limitation
On the first polling loop, the system transitions from an empty state to the current
file-system snapshot. This can trigger unintended rule actions,
as the initial state is not always meaningful.
*** Potential improvement
- Allow rules to distinguish between startup and steady-state polling cycles.
- Configuration to prevent actions triggering on first loop.

** Lack of State Persistence
*** Limitation
File-system state is not persisted between restarts. If the watcher is stopped, crashes or restarts
all prior state is lost.

*** Impact
Missing or duplicate actions caused by restarts.

*** Potential Improvements
Add persistent storage for the file-system state.

** More details in the file-system representation
At the moment we just use a set of ~java.io.File~ objects to represent the previous and new state of
the file-system. This is simple and convenient, but we could add more details (creation time,
edit time, file contents, more historical generations of the file-system state)
depending on requirements.

** Data Shape Enforcement
*** Limitation
There is no formal specification or validation of the shapes of rules, rulesets,
configurations, or watcher method signatures.

*** Impact
More opportunities for bugs and mistakes as the component is extended.

*** Potential Improvement
Use Clojure spec or another schema validation tool to specify and check critical
functions and data shapes.

** Generative testing
With well chosen specifications we could then use generative testing
with ~clojure.spec.test/check~ to improve unit test coverage.

* TODO (for real for real):
- [ ] add s3 watcher
- [ ] example localstack test
- [ ] test runner
- [ ] build script (maybe)
- [ ] describe CI build and e2e testing more
- [ ] diagram in README
- [ ] move rule to ruleset ns
  
 
