#+TITLE: File System Watcher
* Intro
** Purpose
This project is a service component for watching different types of file-systems.
- It uses polling to stay up-to-date with the target file-system.
- It is designed to be extensible to new file-system types.
- It supports configuration to choose polling interval.
- It supports actions based on rules, comparing the previous and new state of
  the target file-system.
** Scope
This project lays the groundwork but it not complete. The intention is to allow for
discussion and adaptation before completing the implementation.

* Documents

* Overview
** High-level Architecture
*** The system
The system is a running instance of this component.

In ~fs-watcher.core~ where we have an entry-point with ~run~, which creates a system and
starts polling on a thread by using a ~future~. This keeps the REPL unblocked and also
would allow us to easily support running multiple, concurrent systems if that becomes a
requirement at a later date.

The state of the system is held in the ~system*~ atom.

The system is updated by ~main-loop~ which triggers polls regulated configured interval.

The system is configured to use a ~watcher~ type based on the file-system type.

*** Watchers
A ~FileSystemWatcher~ protocol is defined in ~fs-watcher.watcher~ with methods: ~connect~,
~poll~ and ~disconnect~. The same namespace also provides wrappers for each of these methods
so that implementations of ~FileSystemWatcher~ do not have to re-implement interactions with
the ~system*~ atom. See comments on each wrapper for more details:

[[file:src/fs_watcher/watcher.clj][FileSystemWatcher]]

Watchers are instantiated as records that implement the ~FileSystemWatcher~ protocol.
There is a watcher ~defrecord~ for each type of file-system supported. For example:

[[file:src/fs_watcher/watchers/local_filesystem.clj][LocalFileSystemWatcher]]

We can see that this implements the FileSystemWatcher protocol, using the given wrappers for
each of the methods.

*** Rulesets and Rules
A ruleset is a collection of rules. A rule is a map of ~:condition~ and ~:action~.
both of these are functions that take the previous and new state of the file-system.

Use of, for example, ~clojure.data.diff~ can be useful in conditions and actions.
#+begin_src clojure
{:condition (fn [prev new] ...)
 :action (fn [prev new] ...)}

#+end_src


**** Condition
A predicate that compares the new and previous file-system state. If the condition is met
the action will be triggered. Comparison of the previous and new state of the file-system
gives a broad space of conditions.

**** Action
Simply a function that is triggered when the condition is met. It also takes the previous
and new state of the file-system since this information may be useful. (Note, maybe it should just
have the system* in scope)

**** Rulesets
Rulesets are collection of rules.
Each ruleset has it's own namespace eg: ~fs-watcher.rulesets.ruleset1~.
The ruleset used by a system is set by configuration.

** Running
*** Configuration

* Testing strategy
A layered approach to testing.
So far I have provided some examples of how to test. Full coverage is not completed yet.

The layers of testing are:
- unit
- integration
- end-to-end

** Unit tests
These test individual functions with example data. Here we are using unit tests as much
for documentation as for ensuring correctness.

My personal preference is to avoid heavy, unnecessary unit testing,
which adds a maintenance burden. Unit tests should only be for functions that
have enough complexity to warrant further documentation or checking.

Example of unit testing is the tests for ~fs-watcher/apply-rules~ which can be found here:

[[file:test/fs_watcher/watcher_test.clj][Watcher tests]]

** Integration tests
This slightly higher level test runs over the connection between two subsystems.
Here the main integrations we are interested in are between our component and the target file-systems.
For our local file-system this is rather simple, we can check the watcher methods when pointed at a
local directory.
We also have an example of the more complex case of the S3 watcher integration test. This is more of
a pseudo-integration test since it runs against a ~localstack~ version of S3.

** End-to-end tests
End-to-end tests can be run all-local but more confidence is given by running these sorts of tests
against a deployed system in a test environment.

* Evolution
So far we have a starting point for a generic file-system watcher component with swappable backends,
interval configuration, rule customization. Once this is complete, there are several ways to improve
or extend this:
- Allow for multiple concurrent systems running on the same component.
- REPL access to hot-swap configuration such as rulesets or interval.

* Trade-offs and Improvement Opportunities
** Creation of rulesets requires code changes
While the choice of ruleset is configurable at invocation, the content of the rulesets is defined
in code, so we have to make code changes to add new rules. If instead we had a rules DSL allowing us
to create rules in configuration this would allow the caller to create custom rules. However,
Such a DSL would limit the rules-space (or add a lot of complexity).The right choice here really
depends on the context.

** Initial file-system representation
With the current setup we may accidentally get behavior that we don't want on the first loop, when
we go from nothing in our file-system representation to something. While this can be somewhat mitigated
in rules definitions, we might want to configure special behavior for the first loop.

** Persistence
If the component needs to restart the previous state will be forgotten. Depending on our context we
might want to store the file-system representation in a database.

** More details in the file-system representation
At the moment we just use a set of ~java.io.File~ objects to represent the previous and new state of
the file-system. This is simple and convenient, but we could add more details (creation time,
edit time, file contents, more historical generations of the file-system state)
depending on requirements.

** Spec, enforce data shapes
Rules, rulesets, configs, function signatures for the ~FileSystemWatcher~ methods and wrappers
could all benefit from spec checks.

** Generative testing
With well chosen specifications we could then use generative testing
with ~clojure.spec.test/check~ to improve unit test coverage.

